package eu.vaadinonkotlin.vaadin10

import eu.vaadinonkotlin.FilterFactory
import eu.vaadinonkotlin.Listeners
import eu.vaadinonkotlin.listeners
import com.github.mvysny.karibudsl.v10.getColumnBy
import com.vaadin.flow.component.Component
import com.vaadin.flow.component.HasSize
import com.vaadin.flow.component.HasValue
import com.vaadin.flow.component.grid.Grid
import com.vaadin.flow.component.grid.HeaderRow
import com.vaadin.flow.data.binder.BeanPropertySet
import com.vaadin.flow.data.binder.PropertyDefinition
import com.vaadin.flow.data.provider.ConfigurableFilterDataProvider
import com.vaadin.flow.data.value.HasValueChangeMode
import com.vaadin.flow.data.value.ValueChangeMode
import com.vaadin.flow.function.SerializableConsumer
import com.vaadin.flow.shared.Registration
import java.io.Serializable
import kotlin.reflect.KClass
import kotlin.reflect.KProperty1
import kotlin.streams.toList

/**
 * Maintains a set of fields - monitors bound fields for values and provides [filter] of type F.
 * Fires [onFilterChangeListeners] on every filter change.
 * @param T the type of items in the grid.
 * @param F the type of the filter
 * @param filterFieldFactory used to create filters from filter components by invoking [FilterFieldFactory.createFilter]
 */
class FilterBinder<T: Any, F: Any>(val filterFieldFactory: FilterFieldFactory<T, F>,
                                   val filterFactory: FilterFactory<F>) : Serializable {

    /**
     * The current filter as generated by [filterFieldFactory] from the most current states of all bound filter fields.
     * Updated on every filter field change.
     */
    var filter: F? = null
        private set

    /**
     * Invoked when the [filter] changes.
     */
    val onFilterChangeListeners = listeners<SerializableConsumer<F?>>()

    private val filterComponents = mutableMapOf<HasValue<*, *>, FilterFieldWatcher<*, *>>()

    /**
     * Binds given filtering field to a container - starts filtering based on the contents of the field, and starts watching for field value changes.
     * Does not add the component to the [headerRow].
     * @param field The field which provides the filtering values, not null. [FilterFieldFactory.createFilter] is used to convert
     * the field's value to a filter.
     * @param property The bean property on which the filtering will be performed, not null.
     */
    fun <E: HasValue.ValueChangeEvent<V?>, V> bind(field: HasValue<E, V?>, property: PropertyDefinition<T, V?>) {
        unbind(field)
        val filterFieldWatcher= FilterFieldWatcher(field, property)
        filterFieldWatcher.registration = field.addValueChangeListener(filterFieldWatcher)
        filterComponents[field] = filterFieldWatcher
    }

    fun unbind(field: HasValue<*, *>) {
        filterComponents.remove(field)?.unregisterWatcher()
    }

    fun unbindAll() {
        filterComponents.keys.toList().forEach { unbind(it) }
    }

    /**
     * Listens on value change on given field and updates [ConfigurableFilterDataProvider.setFilter] accordingly.
     * @property field The field which provides the filtering values.
     * @property property The bean property on which the filtering will be performed.
     * @param V the value type
     */
    private inner class FilterFieldWatcher<E: HasValue.ValueChangeEvent<V?>, V>(private val field: HasValue<E, V?>, private val property: PropertyDefinition<T, V?>) :
        HasValue.ValueChangeListener<E> {

        /**
         * The current container filter, may be null if no filtering is currently needed because the
         * field's value indicates that the filtering is disabled for this column (e.g. the text filter is blank, the filter field is cleared, etc).
         */
        var currentFilter: F? = null

        init {
            valueChange()
        }

        override fun valueChanged(event: E) {
            valueChange()
        }

        private fun valueChange(value: V? = field.value) {
            val newFilter = filterFieldFactory.createFilter(value, field, property)
            setNewFilter(newFilter)
        }

        private fun setNewFilter(newFilter: F?) {
            if (newFilter != currentFilter) {
                currentFilter = newFilter
                recomputeFilter()
            }
        }

        fun unregisterWatcher() {
            setNewFilter(null)
            registration.remove()
        }

        lateinit var registration: Registration
    }

    private fun recomputeFilter() {
        val filters = filterComponents.values.mapNotNull { it.currentFilter } .toSet()
        filter = filterFactory.and(filters)
        onFilterChangeListeners.fire.accept(filter)
    }
}

/**
 * Wraps [HeaderRow] and tracks filter components; also provides support for watching of changes to the filters.
 * @param T the type of items in the grid.
 * @param F the type of the filters accepted by grid's [ConfigurableFilterDataProvider].
 * @param grid the owner grid.
 * @property headerRow the wrapped header row
 */
@Suppress("UNCHECKED_CAST")
class FilterRow<T: Any, F: Any>(val grid: Grid<T>, val itemClass: KClass<T>, val headerRow: HeaderRow,
                                val filterFieldFactory: FilterFieldFactory<T, F>,
                                filterFactory: FilterFactory<F>) : Serializable {

    private val binder: FilterBinder<T, F> = FilterBinder(filterFieldFactory, filterFactory)
    init {
        binder.onFilterChangeListeners.add(SerializableConsumer { filter ->
            (grid.dataProvider as ConfigurableFilterDataProvider<T, F, F>).setFilter(filter)
        })
    }

    /**
     * Map mapping [T] property name to the filtering component generated.
     */
    private val filterComponents = mutableMapOf<String, Component>()

    /**
     * Invoked when the filter changes.
     */
    val onFilterChangeListeners: Listeners<SerializableConsumer<F?>>
        get() = binder.onFilterChangeListeners

    /**
     * Re-generates all filter components in this header row. Removes all old filter components and
     * creates a new set and populates them into the [headerRow].
     */
    fun generateFilterComponents(valueChangeMode: ValueChangeMode = ValueChangeMode.EAGER) {
        binder.unbindAll()
        filterComponents.clear()

        val properties: Map<String, PropertyDefinition<T, *>> =
            BeanPropertySet.get(itemClass.java).properties.toList().associateBy { it.name }
        for (propertyId in grid.columns.mapNotNull { it.key }) {
            val property = properties[propertyId]
            val field: HasValue<*, *>? = if (property == null) null else filterFieldFactory.createField(property)
            if (field != null) {
                (field as? HasValueChangeMode)?.valueChangeMode = valueChangeMode
                binder.bind(field as HasValue<HasValue.ValueChangeEvent<Any?>, Any?>, property!! as PropertyDefinition<T, Any?>)
                filterComponents[propertyId] = field as Component
                (field as? HasSize)?.width = "100%"
            }
            headerRow.getCell(grid.getColumnByKey(propertyId)).setComponent(field as Component?)
        }
    }

    /**
     * @return map mapping [T] property name to the filtering component generated.
     */
    fun getFilterComponents(): Map<String, Component> = filterComponents

    /**
     * Unbinds all filters and clears the [headerRow] (sets null component to every cell).
     */
    fun clear() {
        binder.unbindAll()
        grid.columns.forEach { column -> headerRow.getCell(column).setComponent(null) }
        filterComponents.clear()
    }

    /**
     * Returns the filter component filtering given [property]. Fails if no filter component has been generated for
     * that property.
     */
    fun getFilterComponent(property: KProperty1<T, *>): HasValue<HasValue.ValueChangeEvent<Any?>, Any?> {
        val component = filterComponents[property.name] ?: throw IllegalArgumentException("There is no filter configured for $property")
        return component as HasValue<HasValue.ValueChangeEvent<Any?>, Any?>
    }
}


/**
 * Re-creates filters in this header row. Simply call `grid.appendHeaderRow().generateFilterComponents(grid)` to automatically attach
 * filters to non-generated columns. Please note that filters are not re-generated when the container data source is changed.
 *
 * Note that this function expects that you're using your own custom filter hierarchy. That is rarely the case since most often
 * you use filters from `vok-dataloader`. In such case please use [generateFilterComponents].
 * @param T the type of items in the grid.
 * @param grid the owner grid.
 * @param filterFactory
 * @param filterFieldFactory used to create the filters themselves. If null, [DefaultFilterFieldFactory] is used.
 * @param valueChangeMode how eagerly to apply the filtering after the user changes the filter value. Only applied to [HasValueChangeMode];
 * typically only applies to inline filter
 * components (most importantly [com.vaadin.flow.component.textfield.TextField]), typically ignored for popup components (such as [com.github.vok.framework.NumberFilterPopup])
 * where the values are applied after the user clicks the "Apply" button. Defaults to [ValueChangeMode.EAGER].
 */
@Suppress("UNCHECKED_CAST")
fun <T: Any, F: Any> HeaderRow.generateFilterComponents(grid: Grid<T>, itemClass: KClass<T>,
                                                        filterFactory: FilterFactory<F>,
                                                        filterFieldFactory: FilterFieldFactory<T, F> = DefaultFilterFieldFactory(itemClass.java, filterFactory),
                                                        valueChangeMode: ValueChangeMode = ValueChangeMode.EAGER): FilterRow<T, F> {
    val filterRow = FilterRow(grid, itemClass, this, filterFieldFactory, filterFactory)
    filterRow.generateFilterComponents(valueChangeMode)
    return filterRow
}

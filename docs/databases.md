[Index](index.html) | [Getting Started](gettingstarted.html) | [Guides](vok-guides.html)

# Accessing SQL databases with Vaadin-on-Kotlin

Vaadin-on-Kotlin provides first-class support for the following SQL databases out-of-the-box:

* [H2 Database](http://h2database.com) - a 100% Java database which can be quick-started as an in-memory
  database; perfect for writing tests for your app.
* [PostgreSQL](https://www.postgresql.org/)
* [MariaDB](https://mariadb.org/)
* [MySQL](https://www.mysql.com/)

All other SQL databases may or may not work. Care has been taken to only use the SQL92 syntax,
but we only test and officially support the four of the above-mentioned databases.

> *NoSQL Note*: Only SQL databases which provide appropriate JDBC drivers are currently supported.
There is no direct support for NoSQL databases, but you can easily integrate any NoSQL database with VoK.

> *Note for experienced Java developers*: Experienced Java developers will notice that VoK is *not* using JPA nor Hibernate to access the
database. The reason is that there are inherent issues with the abstraction that JPA
mandates - you can read more about the topic in the [Why Not JPA](http://mavi.logdown.com/posts/5771422) article.

## Basic CRUD ORM

The above horrific acronym stands for inserting, querying and deleting rows from your database,
and mapping those rows into Kotlin objects so that they are easy to work with.

The "CRUD" stands for [Create, read, update and delete](https://en.wikipedia.org/wiki/Create,_read,_update_and_delete) -
the four basic operations performed on a collection of entities mapped to the database, such as a
collection of `Person`s.

The ORM stands for Object-Relational Mapping and stands for mapping database rows into Kotlin objects,
for easier use from within your application. VoK does not use JPA but instead features
a new, vastly simplified database access layer called `vok-orm`.

## About vok-orm

`vok-orm` is a very simple object-relational mapping library, built around the following ideas:

* Simplicity is the most valued property; working with plain SQL commands is preferred over having a type-safe
  query language.
* Kotlin objects merely capture JDBC `ResultSet` rows, by the means of invoking appropriate setters (based on the column name) via
  Java reflection. 
* The entities are just plain objects: they do not track modifications as JPA entities do,
  they do not automatically store modified
  values back into the database. They are never runtime-enhanced and can be final.
* A switch from one type of database to another never happens. We understand that the programmer
  wants to exploit the full potential of the database, by writing SQLs tailored for that particular database.
  `vok-orm` should not attempt to generate SELECTs on behalf of the programmer (except for the very basic ones related to CRUD);
  instead it should simply allow SELECTs to be passed as Strings, and then map the result
  to an object of programmer's choosing.

Because of its simple design principles, `vok-orm` supports not just mapping tables to Kotlin classes,
but it allows mapping of any complex SELECT with joins and everything, even VIEWs, into Kotlin classes.
Naturally this allows you to use any SELECT inside of a Vaadin Grid component which is a
very powerful combination. 

## Persisting simple objects into tables

Please read the [Usage examples](https://github.com/mvysny/vok-orm#usage-examples) chapter of
the `vok-orm` documentation on how to write Kotlin classes that correspond to a particular SQL database
table, and how to create rows in that particular database tables.

In this tutorial, we will modify the [vok-helloworld-app](https://github.com/mvysny/vok-helloword-app) project
- it contains all moving parts but not much of an actual code which makes it ideal for experimenting.

> Note: please read the [Getting Started Guide](gettingstarted.md) on information on these files.

Let us have a `Person` table with the following columns:

| Column | Type | Meaning
| ------ | ---- | ---------
| id | Long? | The primary key, automatically generated by the database, not null. The Kotlin type is nullable since we don't know the ID yet when the person is just being created.
| name | String | The full name of the person, not null.
| age | Int | The age, not null.
| dateOfBirth | LocalDate? | The date of birth, nullable.
| alive | Boolean | Whether the person is alive or deceased.
| maritalStatus | MaritalStatus? | The Marital status. Demoes binding to enum constants.
| modified | Instant? | When the record was last modified in the database

Let's first create a migration script which will prepare the database for us. Create a file
named `web/src/main/resources/db/migration/V01__CreatePerson.sql`, with the following DDL script, depending on your database:

The PostgreSQL DDL script which creates such table is simple:
```postgresql
create table Person (
    id bigserial primary key,
    name varchar(400) not null,
    age integer not null,
    dateOfBirth date,
    alive boolean not null,
    maritalStatus varchar(200),
    modified timestamp not null
)
```

The MySQL/MariaDB DDL script:
```mysql
create table Person (
    id bigint primary key auto_increment,
    name varchar(400) not null,
    age integer not null,
    dateOfBirth date,
    alive boolean not null,
    maritalStatus varchar(200),
    modified timestamp(3) not null
)
```

Finally, the H2 script:
```h2
create table Person (
    id bigint primary key auto_increment,
    name varchar not null,
    age integer not null,
    dateOfBirth date,
    alive boolean not null,
    maritalStatus varchar,
    modified timestamp not null
)
```

> *MaritalStatus Note*: We will store the enum name into the database, e.g. "Single", instead of
just ordinal value of the constant (e.g. 0). The ordinal is easy to accidentally change by the programmer,
e.g. by reordering the enum constants. The data would still load, but it would silently show incorrect
information which is disastrous.

Create the `web/src/main/kotlin/com/example/vok/Person.kt` file with the Kotlin class which will map to this table is as follows:

```kotlin
import com.github.vokorm.Dao
import com.github.vokorm.Entity
import java.time.Instant
import java.time.LocalDate

enum class MaritalStatus { Single, Married, Divorced, Widowed }

data class Person(
    override var id: Long? = null,
    var name: String = "",
    var age: Int = 0,
    var dateOfBirth: LocalDate? = null,
    var alive: Boolean = true,
    var maritalStatus: MaritalStatus? = null,
    var modified: Instant? = null
) : Entity<Long> {
    override fun save() {
        modified = Instant.now()
        super.save()
    }

    companion object : Dao<Person>
}
```

By implementing the `Entity` interface the Kotlin class gains capability to create/update itself into
the database; by having the companion object to implement the `Dao` interface the Kotlin class
gains the lookup capabilities, for example edit the `MyUI.kt` file as follows:

```kotlin
@Theme("mytheme")
class MyUI : UI {
    override fun init(request: VaadinRequest) {
        button("Demo") {
            onLeftClick {
                val person = Person(name = "John Doe", age = 42, alive = false, maritalStatus = MaritalStatus.Single)
                person.save()  // since ID is null, this will create the person and populate the ID
                println(Person.findAll())  // will print [Person(id=1, name=John Doe, age=42 etc)]
                println(Person.getById(person.id!!))  // will print Person(id=1, name=John Doe, age=42 etc)
                person.name = "Agent Smith"
                person.save()   // will update the person in the database, also updating the `modified` field
                println(Person.findById(25L)) // will print null since there is no such person yet
                Person.deleteAll()   // will delete all personnel
                Person.deleteById(42L)   // will delete a person with ID of 42
                println(Category.count()) // will print 0 since we deleted everything
                println(Person.findBy { "name = :name1 or name = :name2"("name1" to "John Doe", "name2" to "Agent Smith") })   // will print []
                Person.deleteBy { (Person::name eq "Agent Smith") }  
                Person.getBy { "name = :name"("name" to "Agent Smith") }   // will fetch exactly one matching person, failing if there is no such person or there are more than one.
                Person.findSpecificBy { "name = :name"("name" to "Agent Smith") } // will fetch one matching person, failing if there are more than one. Returns null if there is none.
            }
        }
    }
}
```

For more information please read the [vok-orm documentation](https://github.com/mvysny/vok-orm).

> Finding Persons: If we want to load a list of persons from the database, the very important thing is to have a zero-arg constructor for the Person class.
This can be achieved either by providing default values for all parameters, or explicitly declaring the zero-arg constructor.
Otherwise the code will fail in runtime: Sql2o will try to construct a `Person` instance for every row returned, using
a zero-arg constructor.

To run the app, just type `./gradlew web:appRun` in your console, or run the `web` module in Tomcat.

## Forms

Forms allows the user to enter the values of a newly created record, or edit the values of
already existing ones. Validation is typically employed, to guide the user to enter
meaningful data.

We will use Vaadin Binder to bind form components to properties of the `Person` Kotlin class.
A source code of the form is shown below, just add the following code into the `MyUI.kt` file:

```kotlin
class PersonEditor : VerticalLayout() {
    private val binder = beanValidationBinder<Person>()
    var person: Person? = null
        set(value) {
            field = value
            if (value != null) binder.readBean(value)
        }

    init {
        isMargin = false
        textField("Name") {
            bind(binder).bind(Person::name)
        }
        textField("Age") {
            bind(binder).toInt().bind(Person::age)
        }
        dateField("Date Of Birth") {
            bind(binder).bind(Person::dateOfBirth)
        }
        checkBox("Alive") {
            bind(binder).bind(Person::alive)
        }
        comboBox<MaritalStatus>("Marital Status") {
            setItems(*MaritalStatus.values())
            bind(binder).bind(Person::maritalStatus)
        }
        button("Save Person", { event ->
            val person = person!!
            if (binder.validate().isOk && binder.writeBeanIfValid(person)) {
                person.save()
                println(Person.findAll())
            } else {
                event.button.componentError = UserError("There are invalid fields")
            }
        })
    }
}

fun HasComponents.personEditor(block: PersonEditor.()->Unit = {}) = init(PersonEditor(), block)
```

This will create a form as a reusable component which we can then use in the `MyUI` as follows:

```kotlin
@Theme("mytheme")
class MyUI : UI() {
    override fun init(request: VaadinRequest) {
        personEditor {
            person = Person()
        }
    }
}
```

The form will allow you to create a new person, or edit an existing one. However,
the user can now enter invalid data, such as negative numbers for age etc.

We will use so-called JSR303 validation annotations, which will make the `beanValidationBinder` validate the bean for us. Edit the `Person` class
as follows:

```kotlin
import javax.validation.constraints.Min
import javax.validation.constraints.NotNull
import javax.validation.constraints.Past

data class Person(
    override var id: Long? = null,
    @field:NotNull
    @field:Length(min = 2)
    var name: String = "",
    @field:Min(1)
    var age: Int = 0,
    @field:Past
    var dateOfBirth: LocalDate? = null,
    var alive: Boolean = true,
    var maritalStatus: MaritalStatus? = null,
    var modified: Instant? = null
) : Entity<Long> {
    override fun save() {
        modified = Instant.now()
        super.save()
    }

    companion object : Dao<Person>
}
```

> *Important*: Make sure to attach those annotations to `field`! If you would just write `@Min(1)`, the annotation would be applied to the getter
instead to the field, and `beanValidationBinder` would ignore it.

Now, typing in incorrect values will make the field go red and show the validation errors; the "Save" button will also not create a Person
instance if the values are invalid.

## Using `vok-orm` with Vaadin Grid

Vaadin Grid is a very powerful component which allows you to show a lazy-loaded list of rows
on a web page. It allows the user to:

* efficiently scroll the list, lazy-loading more data as they are scrolled into the viewport,
* sorting by one or more columns (shift-click the caption to add sorting columns)
* filtering from code
* VoK provides means to auto-generate filter components and auto-populate them into the Grid,
  which provides you with a simple means to allow the user to filter as well.

You can find more information about the Vaadin Grid at the [Vaadin Grid Documentation](http://wc.demo.vaadin.com/mcm/out/framework/components/components-grid.html) page.

### Showing entities in Grid

We will start with the most basic Grid which will show the list of `Person`. By default the Grid shows all columns,
therefore we need to restrict the columns a bit:

```kotlin
class MyUI : UI {
    override fun init(request: VaadinRequest) {
        grid(Person::class, dataProvider = Person.dataProvider) {
            setSizeFull()
            
            // show these columns, and in this order
            showColumns(Person::id, Person::name, Person::age, Person::dateOfBirth, Person::maritalStatus, Person::alive, Person::modified)
            
            column(Person::dateOfBirth) {
                setRenderer(LocalDateRenderer())
            }
            column(Person::modified) {
                // an example of a Renderer which converts the value to string.
                // it would be better to employ value provider for this; yet Vaadin does not allow for the value provider to be changed after the column is created.
                setRenderer(ConvertingRenderer<Instant?>({ it!!.toString() }))
            }
            addColumn({ "Delete" }, ButtonRenderer<Person>({ event -> event.item.delete(); refresh() }))
        }
    }
}
```

This is a full-blown Grid with lazy-loading and SQL-based (so not in-memory) sorting working out-of-the-box. Adding the possibility
for the user to filter on the contents of the Grid is really easy, just add the following call, as the last
line into the `grid { ...  }` block:

```kotlin
appendHeaderRow().generateFilterComponents(this, Person::class)
```

This will create additional Grid header and will auto-populate it with filters. You can finetune
the generator by extending the `DefaultFilterFieldFactory`; see the `generateFilterComponents()`
documentation for details.

You can also create an unremovable programmatic filter easily:
```kotlin
grid(Person::class, dataProvider = Person.dataProvider.withFilter { Person::age between 20..60 }) {
    // ...
}
```

The trick here is to *always* use DataProviders with configurable filters. By default Vaadin DataProviders do
not support setting filters, but that would disable the support for user-defined filters (the filters would fail in runtime
when trying to set the user-defined filter to the data provider).

Therefore, built-in VoK data providers offered for all entities by the `Dao` interface (via the `dataProvider` extension property) are already configurable.
User filters can thus cast them to `VokDataProvider` and set filters to them. However, that will overwrite
any previously set filter, and sometimes we want to prevent that. The important distinction here is as follows:

* `Person.dataProvider.apply { setFilter { Person::age between 20..60 } }` will set a filter to the data provider,
  but this filter will be removed by any filtering value typed in by the user into the filtering component.
* That's why you should use `Person.dataProvider.withFilter { Person::age between 20..60 }`. The `withFilter()` function
  takes an existing DataProvider and creates a new one, which delegates all data-fetching calls
  to the old one but always ANDs given filter with any filters set by the `setFilter()`.

### Showing an arbitrary output of any SQL SELECT command

Say that we have a join which joins Persons with their departments. Something like the following:

```sql92
SELECT person.name as personName, dept.name as deptName FROM Person person, Department dept WHERE person.deptId=dept.id
```

To capture the outcome of this SELECT we can simply declare the following class:

```kotlin
data class PersonDept(var personName: String? = null, var deptName: String? = null) : Serializable
```

Of course the `PersonDept` will not be an entity (since it's not represented by a single Table and cannot
be saved nor deleted), hence it does not implement the `Entity` interface and we won't reuse the `Dao`-induced finders.

To load instances of this particular class, we will need to write our own finder methods. We will directly
use the Sql2o capabilities to map any SELECT result into an arbitrary class. We just have to make
sure that the SQL SELECT column names exactly match the Kotlin properties names (and beware that it's string case-sensitive matching):

```kotlin
data class PersonDept(var personName: String? = null, var deptName: String? = null) {
    companion object {
        fun findAll(): List<PersonDept> = db {
            con.createQuery("SELECT person.name as personName, dept.name as deptName FROM Person person, Department dept WHERE person.deptId=dept.id")
                .executeAndFetch(PersonDept::class.java)
        }
        
        val dataProvider: VokDataProvider<PersonDept> get() =
                SqlDataProvider(SelectResult::class.java,
                    "SELECT person.name as personName, dept.name as deptName FROM Person person, Department dept WHERE person.deptId=dept.id \{\{WHERE}} order by 1=1\{\{ORDER}} \{\{PAGING}}",
                    idMapper = { it }).withConfigurableFilter2()
    }
}
```

> Note: a bug in Github Pages prevents me to just write double-curly-braces: Please make sure
to remove the backslashed `\{` and just replace them with just curly braces: `{`. The `SqlDataProvider` class
contains extensive documentation on this topic, please consult the kdoc for that class in your IDE.

The `dataProvider` clause will allow us to use the `PersonDept` class with Vaadin Grid simply, with the full
power of lazy-loading, sorting and filtering:

```kotlin
class MyUI : UI {
    override fun init(request: VaadinRequest) {
        grid(PersonDept::class, dataProvider = PersonDept.dataProvider) {
            setSizeFull()
            appendHeaderRow().generateFilterComponents(this, PersonDept::class)
        }
    }
}
```
